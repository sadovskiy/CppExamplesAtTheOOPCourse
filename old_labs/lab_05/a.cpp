/*
 *
 * Copyright (C) 2012 Dept. Information Systems, Technology and Automation in Civil Engineering (ISTAC),
 * Moscow State University of Civil Engineering (MSUCE or MGSU)
 *
 * Written by Sadovskiy B. S.
 *
 *
 * Права на программу (С) 2012 Кафедра информационных систем, технологий и автоматизации в строительстве (ИСТАС),
 * Московский Государственный строительный университет (МГСУ)
 *
 * Написана Садовским Б. С.
 *
 */

#include "a.hpp"

// Выделяем динамическую память для переменных указателей
A::A(): ptr_a(new int(0)), ptr_ch(new char)
{

}

// Выделение памяти для случая, если входная переменная целого типа
A::A(const int n): ptr_a(new int(n)), ptr_ch(new char)
{

}

// Выделение памяти для случая, если входная переменная символьного типа.
// Для символьных данных не забываем, что это массив и перед копированием строки
// надо выделить достаточно места в памяти (в области кучи), для её размещения
A::A(const char* str): ptr_a(new int), ptr_ch(new char[strlen(str) + 1])
{
    // Теперь копируем строку во вновь созданную область памяти
    strcpy(ptr_ch, str);
}

// Выделение памяти для входных переменных целого и символьного типа
A::A(const int n, const char* str): ptr_a(new int(n)), ptr_ch(new char[strlen(str) + 1])
{
    strcpy(ptr_ch, str);
}

// В деструкторе удаляем выделенные участки памяти
A::~A()
{
    delete ptr_a;
    delete ptr_ch;
}

// В конструкторе копирования переносим наши данные из одного объекта в другой,
// не забывая о правильном копировании в случае работы с динамической памятью
A::A(const A& other): ptr_a(new int(*other.ptr_a)), ptr_ch(new char[strlen(other.ptr_ch) + 1])
{
    strcpy(ptr_ch, other.ptr_ch);
}

// В операции присваивания переносим наши данные из одного объекта в другой,
// не забывая о правильном копировании в случае работы с динамической памятью
A& A::operator=(const A& rhs)
{
    // Делаем проверку на самоприсваивание объекта,
    // если объект оказывается одним и тем же, то
    // выполнять присваивание не нужно
    if (this == &rhs) return *this;

    // Выделяем память под новые объекты,
    // для целой переменной и её одновременной инициализации
    ptr_a = new int(*rhs.ptr_a);
    // для массива символов (строка) вначале выделяем необходимое количество памяти
    ptr_ch = new char[strlen(rhs.ptr_ch) + 1];
    // затем копируем строку
    strcpy(ptr_ch, rhs.ptr_ch);

    // Выходим с возвратом объекта для случая
    // составных операций
    return *this;
}

// Вставляем данные в уже существующую переменную
void A::intSet(const int n)
{
    *ptr_a = n;
}

// Для вставки строк надо сначала удалить старую строку и только потом
// выделять память под новую, так как размеры у строк могут не совпадать
// и возможно возникновение ситуации с переполнением буфера
void A::chSet(const char* str)
{
    delete ptr_ch;
    ptr_ch = new char[strlen(str) + 1];
    strcpy(ptr_ch, str);
}

// Извлекаем переменную
int A::intGet() const
{
    return *ptr_a;
}

char* A::chGet() const
{
    return ptr_ch;
}

// Выводим на экран содержимое переменных
void A::show() const
{
    std::cout << "ptr_a: " << *ptr_a << std::endl;
    std::cout << "ptr_ch: \"" << *ptr_ch << "\"" << std::endl;
}
